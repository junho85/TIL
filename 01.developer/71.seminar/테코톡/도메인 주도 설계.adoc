= 라테의 도메인 주도 설계

* https://www.youtube.com/watch?v=VIfNipL5KkU[[10분 테코톡\] ☕️라테의 도메인 주도 설계 2020.11.17]

...들어도 잘 모르겠다...

== 도메인(Domain)
* 사용자가 사용하는 것, 소프트웨어로 해결하고자 하는 문제 영역
* 비즈니스 영역

== 도메인 주도 설계(DDD)
* 도메인을 중심으로 하는 개발 방식 -> 도메인에 관련된 문제를 해결하는 것
* 복잡한 도메인을...
-> 도메인의 복잡성을...

== 개발 프로세스
* 요구사항 분석 -> 설계 -> 구현

* 도메인 --(추상화)--> 모델 --(실체화)-->소프트웨어

도메인 전문가가 도메인 분석하고 모델

개발자가 모델로 소프트웨어 구현

소프트웨어 개발과 모델링의 불일치 발생

=== 유비쿼터스 랭귀지 (보편언어)
* 도메인에 대한 어휘를 이해관계자(도메인 전문가, 개발자, 분석가...)들이 공통적으로 의미를 이해할 수 있도록 정의하는 것

=== 모델 주도 설계
* 분석과 설계를 나누지 않으며 분석/설계/구현의 모든 단계를 관통하는 하나의 모델을 유지
* 모델링 통해 가져올 수 있는 통찰을 코드에도 적용
* 모델 == 코드

=== 도메인 모델(Domain Model)
* 도메인에 대한 구체적인 설계, 도메인을 개념적으로 표현한 것
* 개념들의 관계를 표현한 모델
* 문제 영역을 시각화

=== 도메인 주도 설계(Domain Driven Design)
* 복잡한 소프트웨어는 기술 자체의 복잡성 보다는 도메인 자체의 복잡성에 기인
->
->

=== 등장 배경
* 데이터에 종속적인 애플리케이션
* 모델링과 개발과의 불일치

=== 데이터 중심적인 접근법
* 기존 개발은 DB 테이블 중심
* 빈약한 도메인 모델

=== 빈약한 도메인 모델
* Getter와 Setter만으로 구성 된 모델
* 데이터만 가지는 데이터홀더 개념
* Big Service layer
...

=== DDD Overview

* 전술적 설계 - 구체적 설계
* 전략적 설계 - 개념 설계

=== 전략적 설계
* 복잡한 도메인의 맥락(Context) 경계를 명확히 정의하는 과정
* Bounded Context안의 도메인 모델에서 보편 언어를 개발하는 방법
* 도메인에서 서브 도메인으로 복잡성을 분리
** 핵심, 지원 도메인 파악
* 컨텍스트 맵핑 기술을 활용해 여러 개의 Bounded Context를 통합
* 이벤트 스토밍 기법을 활용해 Bounded Context 식별

=== 진흙 덩어리 문제

=== 전술적 설계
* 전략적 설계에서 더 상세한 부분(바운디드 컨텍스트 내부) 모델링
* Model Driven Design
* 빌딩 블록(패턴)을 사용해 모델링 - Aggregate 패턴
* 계층형 아키텍처를 통한 도메인 모델 분리
* 도메인 이벤트를 통해 도메인을 보다 명확히 모델링

=== 전술적 설계 - Building Block
.Entity
* 속성이 아닌 식별성을 기준으로 정의되는 도메인 객체

.Value Object
* 식별성이 아닌 속성을 이용해 정의되는 불볍 객체
* 모든 것에 식별성을 부여하고 Entity로 관리한다면 복잡성 증가
* 과거 Java의 DTO(Data Trasfer Object)패턴의 Value Object와 관계없음
* Entity와 Value Object를 구별하는 첫 번쨰 조건은 식별성
* 식별성을 가지면 Entity 그렇지 않으면 Value Object

.Service
* Domain Object에서 위치시키기 어려운 operation을 가지는 객체
* 여러 Domain Object 다루는 연산 Service의 오퍼레이션은 일반적으로 stateless
* Domain Object에 해당되는 역할을 service operation으로 만드는 경우 도메인 역할을 침범하여 강 결합이 일어남.
...

.Aggregate
* 연관도니 Entity와 Value Object의 묶음. 일관성과 트랜잭션, 분산의 단위, 캡슐화를 통한 복잡성 관리
* 예를 들어 쇼핑몰 사이트에서 주문 Entity 내에 배송주소 정보를 우편번호, 주소1, 주소2, 상세주소, 이런식으로 각 컬럼으로 정의하는 것이 아니라, 주소라는 Value Object를 별도로 작성하고 주문 Entity는 주소 Value Object를 포함하는 방식으로 관계 일관성 및 단순화를 유지한다.

.Factory
* 복잡한 Entity의 생성 절차에 캡슐화 할 수 있는 개념
* 생성하기 복잡한 Aggregate내의 여러 객체를 동시에 생성
* 생성시 Aggregate의 일관성 유지

.Repository
* 도메인 영역과 데이터 인프라스트럭쳐 계층을 분리하여 데이터 계층에 댛나 결합도를 낮추기 위한 방안
* 생성된 Aggregate에 대한 영속성 관리. 조회, 등록, 수정, 삭제시 Aggregate의 일관성 유지
* DB 및 데이터 저장소의 데이터를 조회하고 저장하는 경우 Repository를 활용한다.

출처: https://cyberx.tistory.com/57


=== DDD
* 흔히 DDD를 떠올리면 DDD의 전술적 설계(Buliding Block)에 대한 개념을 많이 떠올림(Entity, Value Object, Aggregate)
* 물론 DDD의 전술적 설계만 했을 시에도 장점 존재 - DDD Lite
* 하지만 DDD는 이러한 패턴보다는 협업을 통한 문제 해결이 더 강조
