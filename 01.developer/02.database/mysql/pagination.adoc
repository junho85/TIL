:hardbreaks:
= Pagination

== No Offset 커서기반 페이징
id 기준으로 정렬된 테이블에서 페이징을 구현할 때, offset을 사용하면 성능이 떨어진다. offset을 사용하면 테이블의 전체 레코드를 읽어야 하기 때문이다. 따라서 offset을 사용하지 않고 커서기반 페이징을 구현하면 성능향상에 도움을 준다. 커서기반 페이징은 id 기준으로 정렬된 테이블에서만 사용할 수 있다. id 기준으로 정렬된 테이블이 아니라면, id 외에 다른 컬럼을 기준으로 정렬해야 한다. 예를 들어, id, name 컬럼으로 정렬된 테이블이 있다면, id, name 컬럼을 기준으로 페이징을 구현해야 한다. id, name 컬럼을 기준으로 페이징을 구현하면, id, name 컬럼을 기준으로 정렬된 테이블이 아니라면, 페이징이 제대로 동작하지 않는다. 따라서 id 기준으로 정렬된 테이블에서만 커서기반 페이징을 구현할 수 있다.

UI 상으로는 more 버튼으로 그 다음 내용 불러오는 방식

성능상 여러모로 유리하다.

단점은 엄청 뒷쪽 페이지로 이동하기 불편하다. 100페이지로 이동하려면 "더보기" 버튼을 99번 눌러야 된다.

== Offset 기반 페이징
limit에 offset을 이용해서 페이징을 구현하는 방식

장점: 엄청 뒤쪽 페이지로 이동하기가 편리하다. (다만 느려진다)
단점: 페이지가 길어지면 뒤쪽 페이지를 불러 올 때 성능저하가 발생한다. 커버링 인덱스를 사용하면 개선이 가능하지만 인덱스 용량이 커진다. 쿼리도 조금 복잡해진다. Oracle의 페이징 쿼리랑 조금 비슷해지는 느낌?


== References

https://jojoldu.tistory.com/528[1. 페이징 성능 개선하기 - No Offset 사용하기 2020.10.15]

https://jojoldu.tistory.com/529[2. 페이징 성능 개선하기 - 커버링 인덱스 사용하기 2020.10.24]
