:hardbreaks:
= saga

https://redux-saga.js.org/docs/introduction/GettingStarted

https://redux-saga.js.org/docs/api/


== References
* https://velog.io/@devmag/%EC%82%AC%EC%9D%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-10.-saga-%EC%AA%BC%EA%B0%9C%EA%B8%B0-reducer-%EC%97%B0%EA%B2%B0-%EC%95%A1%EC%85%98-%EB%B0%8F-%EC%83%81%ED%83%9C-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0[[사이드 프로젝트] #10. saga 쪼개기, reducer 연결, 액션 및 상태 정리하기]

sagas 폴더내에서 index.js 파일에서 redux-saga 코드를 계속 쓰다보면 코드가 매우 길어짐. 하나의 리퀘스트에 세 개로 구분하면(진행중, 성공, 실패) 굉장히 길어질 것이다. 그러므로 reducer처럼 user, post 관련 코드들을 나눠보자.

sagas/user.js

[source,js]
----
import { all, fork, takeLatest, call, put, delay } from 'redux-saga/effects';
import axios from 'axios';

function logInAPI(data) {
  return axios.post('/api/login', data);
}

function* logIn(action) {
    try {
        // const result = yield call(logInAPI, action.data);
        yield delay(1000);
        yield put({
            type: 'LOG_IN_SUCCESS',
            // data: result.data,
        });
    } catch (err) {
        yield put({
            type: 'LOG_IN_FAILURE',
            data: err.response.data,
        });
    }
}

function logOutAPI() {
    return axios.post('/api/logout');
}

function* logOut() {
    try {
        // const result = yield call(logOutAPI);
        yield delay(1000);
        yield put({
            type: 'LOG_OUT_SUCCESS',
            // data: result.data,
        });
    } catch (err) {
        yield put({
            type: 'LOG_OUT_FAILURE',
            data: err.response.data,
        });
    }
}

function* watchLogIn() {
    yield takeLatest('LOG_IN_REQUEST', logIn);
}

function* watchLogOut() {
    yield takeLatest('LOG_OUT_REQUEST', logOut);
}

export default function* userSaga() {
    yield all([
        fork(watchLogIn),
        fork(watchLogOut),
    ])
}
----

...

2. reducer와 연결하기
saga에서 세 가지 경우(진행중, 성공, 실패)로 나눴으므로 reducer도 그에 맞춰서 세 가지로 나누고 그에 알맞게 state를 변화시켜줘야한다. switch문이 굉장히 길어질것이다.

진행중이 추가되었으므로 initialState에도 추가해주자.
action creator 쪽 코드에도 변화가 생긴다. 이름과 type을 바꿨다.

reducers/user.js

[source,js]
----
export const initialState = {
    isLoggingIn: false, // 로그인 시도중
    isLoggedIn: false,
    isLoggingOut: false, // 로그아웃 시도중
    me: null,
    signUpData: {},
    loginData: {},
};

// action creators
export const loginRequestAction = (data) => {
    return {
        type: 'LOG_IN_REQUEST',
        data,
    }
};

export const logoutRequestAction = () => {
    return {
        type: 'LOG_OUT_REQUEST',
    }
};

const reducer = (state = initialState, action) => {
    switch (action.type) {
        case 'LOG_IN_REQUEST': {
            return {
                ...state,
                isLoggingIn: true,
            }
        }
        case 'LOG_IN_SUCCESS': {
            return {
                ...state,
                isLoggingIn: false,
                isLoggedIn: true,
                me: action.data,
            }
        }
        case 'LOG_IN_FAILURE': {
            return {
                ...state,
                isLoggingIn: false,
                isLoggedIn: false,
            }
        }
        case 'LOG_OUT_REQUEST': {
            return {
                ...state,
                isLoggingOut: true,
            }
        }
        case 'LOG_OUT_SUCCESS': {
            return {
                ...state,
                isLoggingOut: false,
                isLoggedIn: false,
                me: null,
            }
        }
        case 'LOG_OUT_FAILURE': {
            return {
                ...state,
                isLoggingOut: false,
            }
        }
        default: {
            return state,
        }
    }
};

export default reducer;
----

3. 컴포넌트 코드 변경
saga과 reducer에 변화가 생겼으므로 컴포넌트 코드들에도 변경사항이 생김

1. LoginForm 컴포넌트
LoginForm 컴포넌트의 경우에는 reducer를 import하는 이름과 로그인 진행중인 상태를 알려주는 isLogginIn 을 갖고오게 된다.

[source,js]
----
...
import { useDispatch, useSelector } from 'react-redux';
import { loginRequestAction } from '../reducers/user';
...
const LoginForm = () => {
    const dispatch = useDispatch();
    const { isLoggingIn } = useSelector((state) => state.user);
    ...

        ...
        <ButtonWrapper style={style}>
            <Button type="primary" htmlType="submit" loading={isLoggingIn}>로그인</Button>
            <Link href="/signup"><a><Button>회원가입</Button></a></Link>
        </ButtonWrapper>
        ...
----

2. UserProfile 컴포넌트
UserProfile 컴포넌트의 경우에는 로그아웃 버튼 관련되어서 코드를 수정해주면 된다.
또한, 자기자신에 대한 정보를 보여주도록 me 를 useSelector로 갖고와서 사용하도록 한다.

[source,js]
----
import { logoutRequestAction } from '../reducers/user';

const UserProfile = () => {
    const dispatch = useDispatch();
    const { me, isLoggingOut } = useSelector((state) => state.user);
    ...
        <Card.Meta
            avatar={<Avatar>{me.nickname[0]}</Avatar>}
            title={me.nickname}
        />
        <Button onClick={onLogout} loading={isLoggingOut}>로그아웃</Button>
        ...
}
----

4. 흐름 이해하기

현재 redux-saga까지 추가되어서 코드 길이도 길어지고 과정도 복잡해졌다. 흐름이 어떻게 되는지 파악하는게 중요하다. 로그인을 하는 과정을 보면서 이 흐름에 대해서 알아보자.

1. 아이디, 비밀번호 입력 후 로그인 버튼 클릭
2. loginRequestAction 실행
3. reducer에서 switch 문에 있는 'LOG_IN_REQUEST' 부분이 실행된다.
4. 거의 동시에 redux-saga에서 eventListener 와 비슷한 역할을 하는 watchLogIn 함수가 실행된다. 해당 함수를 통해 login 함수가 실행된다.
5. 그 다음에 redux-saga에서 통신이 끝나면 `LOG_IN_SUCCESS`를 dispatch하게 된다.
6. reducer에서 switch 문에 있는 'LOG_IN_SUCCESS' 부분이 실행된다. isLoggedIn이 true가 되고 me에 데이터가 들어가게된다.
7. isLoggedIn이 true가 되므로 AppLayout에서 컴포넌트가 LoginForm에서 UserProfile로 리렌더링된다.

...

React - 상태관리 Redux-Saga 2022.08.03
https://ji-musclecode.tistory.com/67


Redux의 미들웨어로 많이 사용되는 Redux-Saga

redux-saga는 redux middleware 라이브러리 중 하나로, Action과 Reducer 사이에서 흐름을 제어함.
Action을 모니터링 하다가 Action이 발생하면 Reducer가 Action을 처리하기 전에 다양한 작업을 할 수 있음

* 기존 요청 취소, 불필요한 중복 요청 방지 가능
* 비동기 작업을 처리하는데 효과적
* 특정 Action이 발생했을 때 이에 따라 다른 Action이 Dispatch 되게 하거나, JS 코드를 실행할 수 있음

1. actions, reducers, sagas 폴더를 만들고 파일들을 만들어줌.
actions/playAction.js
reducers/index.js
sagas/PlaySaga.js, rootSaga.js

예제 확인을 위해 API, Components 폴더를 만들고 각각 파일을 만들어줌.
API/API.js
Components/index.js, play1.js

2. 위에서 만든 Redux-Saga를 적용

기존 Redux의 store를 선언할 때와 비교해보면 createSagaMiddleware로 미들웨어를 만들어 applyMiddleware로 적용시키고 rootSaga를 넣어서 해당 Saga를 적용할 것이라고 알려주는 것이 추가됨

3. redux-saga 사용

기존 Redux를 적용시켰을 때와 비교해보면 별 다른 차이점이 없음. 하지만 내부 데이터 흐름이 다름.

4. 결과 확인
1 에서 10 까지 순서대로 나옴

5. 데이터 흐름 확인

debugger 와 콘솔을 찍으면서 확인

* mapDispatchToProps에서 정의했던 PostsRequest 함수 호출
* PostRequest 액션 함수가 호출됨. PostsRequest 함수는 "getPosts"라는 type을 리턴하여 액션이 발생
* redux-saga에서는 이를 감지하고 액션에 해당하는 동작 getPostData 함수를 호출
* getPostData 함수는 yield call을 만나 함수의 리턴이 있을 때까지 기다림
* 즉 callSelectAPI 함수를 호출하고 callSelectAPI 함수는 axios.get()을 통해 받아온 데이터를 리턴하면 다음 동작을 수행함
* yield put을 만나 새로운 액션에 대해 Displatch
* reducer에 액션에 대한 state 변경이 있으므로 이를 수행함
* 변경된 state는 mapStateToProps를 통해서 컴포넌트에 전달되고 우리는 최종적으로 4번의 결과 화면이 렌더링 된 것을 확인할 수 있음

