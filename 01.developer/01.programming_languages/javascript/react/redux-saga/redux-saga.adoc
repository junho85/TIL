:hardbreaks:
= saga

Redux-saga는 react/redux 애플리케이션의 사이드 이펙트, 예를 들면 데이터 fetching이나 브라우저 캐시에 접근하는 순순하지 않은 비동기 동작들을 더 쉽고 보기 좋게 만드는 것을 목적으로 하는 라이브러리

https://redux-saga.js.org/docs/introduction/GettingStarted

https://redux-saga.js.org/docs/api/


== References
* https://velog.io/@devmag/%EC%82%AC%EC%9D%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-10.-saga-%EC%AA%BC%EA%B0%9C%EA%B8%B0-reducer-%EC%97%B0%EA%B2%B0-%EC%95%A1%EC%85%98-%EB%B0%8F-%EC%83%81%ED%83%9C-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0[[사이드 프로젝트] #10. saga 쪼개기, reducer 연결, 액션 및 상태 정리하기]

sagas 폴더내에서 index.js 파일에서 redux-saga 코드를 계속 쓰다보면 코드가 매우 길어짐. 하나의 리퀘스트에 세 개로 구분하면(진행중, 성공, 실패) 굉장히 길어질 것이다. 그러므로 reducer처럼 user, post 관련 코드들을 나눠보자.

sagas/user.js

[source,js]
----
import { all, fork, takeLatest, call, put, delay } from 'redux-saga/effects';
import axios from 'axios';

function logInAPI(data) {
  return axios.post('/api/login', data);
}

function* logIn(action) {
    try {
        // const result = yield call(logInAPI, action.data);
        yield delay(1000);
        yield put({
            type: 'LOG_IN_SUCCESS',
            // data: result.data,
        });
    } catch (err) {
        yield put({
            type: 'LOG_IN_FAILURE',
            data: err.response.data,
        });
    }
}

function logOutAPI() {
    return axios.post('/api/logout');
}

function* logOut() {
    try {
        // const result = yield call(logOutAPI);
        yield delay(1000);
        yield put({
            type: 'LOG_OUT_SUCCESS',
            // data: result.data,
        });
    } catch (err) {
        yield put({
            type: 'LOG_OUT_FAILURE',
            data: err.response.data,
        });
    }
}

function* watchLogIn() {
    yield takeLatest('LOG_IN_REQUEST', logIn);
}

function* watchLogOut() {
    yield takeLatest('LOG_OUT_REQUEST', logOut);
}

export default function* userSaga() {
    yield all([
        fork(watchLogIn),
        fork(watchLogOut),
    ])
}
----

...

2. reducer와 연결하기
saga에서 세 가지 경우(진행중, 성공, 실패)로 나눴으므로 reducer도 그에 맞춰서 세 가지로 나누고 그에 알맞게 state를 변화시켜줘야한다. switch문이 굉장히 길어질것이다.

진행중이 추가되었으므로 initialState에도 추가해주자.
action creator 쪽 코드에도 변화가 생긴다. 이름과 type을 바꿨다.

reducers/user.js

[source,js]
----
export const initialState = {
    isLoggingIn: false, // 로그인 시도중
    isLoggedIn: false,
    isLoggingOut: false, // 로그아웃 시도중
    me: null,
    signUpData: {},
    loginData: {},
};

// action creators
export const loginRequestAction = (data) => {
    return {
        type: 'LOG_IN_REQUEST',
        data,
    }
};

export const logoutRequestAction = () => {
    return {
        type: 'LOG_OUT_REQUEST',
    }
};

const reducer = (state = initialState, action) => {
    switch (action.type) {
        case 'LOG_IN_REQUEST': {
            return {
                ...state,
                isLoggingIn: true,
            }
        }
        case 'LOG_IN_SUCCESS': {
            return {
                ...state,
                isLoggingIn: false,
                isLoggedIn: true,
                me: action.data,
            }
        }
        case 'LOG_IN_FAILURE': {
            return {
                ...state,
                isLoggingIn: false,
                isLoggedIn: false,
            }
        }
        case 'LOG_OUT_REQUEST': {
            return {
                ...state,
                isLoggingOut: true,
            }
        }
        case 'LOG_OUT_SUCCESS': {
            return {
                ...state,
                isLoggingOut: false,
                isLoggedIn: false,
                me: null,
            }
        }
        case 'LOG_OUT_FAILURE': {
            return {
                ...state,
                isLoggingOut: false,
            }
        }
        default: {
            return state,
        }
    }
};

export default reducer;
----

3. 컴포넌트 코드 변경
saga과 reducer에 변화가 생겼으므로 컴포넌트 코드들에도 변경사항이 생김

1. LoginForm 컴포넌트
LoginForm 컴포넌트의 경우에는 reducer를 import하는 이름과 로그인 진행중인 상태를 알려주는 isLogginIn 을 갖고오게 된다.

[source,js]
----
...
import { useDispatch, useSelector } from 'react-redux';
import { loginRequestAction } from '../reducers/user';
...
const LoginForm = () => {
    const dispatch = useDispatch();
    const { isLoggingIn } = useSelector((state) => state.user);
    ...

        ...
        <ButtonWrapper style={style}>
            <Button type="primary" htmlType="submit" loading={isLoggingIn}>로그인</Button>
            <Link href="/signup"><a><Button>회원가입</Button></a></Link>
        </ButtonWrapper>
        ...
----

2. UserProfile 컴포넌트
UserProfile 컴포넌트의 경우에는 로그아웃 버튼 관련되어서 코드를 수정해주면 된다.
또한, 자기자신에 대한 정보를 보여주도록 me 를 useSelector로 갖고와서 사용하도록 한다.

[source,js]
----
import { logoutRequestAction } from '../reducers/user';

const UserProfile = () => {
    const dispatch = useDispatch();
    const { me, isLoggingOut } = useSelector((state) => state.user);
    ...
        <Card.Meta
            avatar={<Avatar>{me.nickname[0]}</Avatar>}
            title={me.nickname}
        />
        <Button onClick={onLogout} loading={isLoggingOut}>로그아웃</Button>
        ...
}
----

4. 흐름 이해하기

현재 redux-saga까지 추가되어서 코드 길이도 길어지고 과정도 복잡해졌다. 흐름이 어떻게 되는지 파악하는게 중요하다. 로그인을 하는 과정을 보면서 이 흐름에 대해서 알아보자.

1. 아이디, 비밀번호 입력 후 로그인 버튼 클릭
2. loginRequestAction 실행
3. reducer에서 switch 문에 있는 'LOG_IN_REQUEST' 부분이 실행된다.
4. 거의 동시에 redux-saga에서 eventListener 와 비슷한 역할을 하는 watchLogIn 함수가 실행된다. 해당 함수를 통해 login 함수가 실행된다.
5. 그 다음에 redux-saga에서 통신이 끝나면 `LOG_IN_SUCCESS`를 dispatch하게 된다.
6. reducer에서 switch 문에 있는 'LOG_IN_SUCCESS' 부분이 실행된다. isLoggedIn이 true가 되고 me에 데이터가 들어가게된다.
7. isLoggedIn이 true가 되므로 AppLayout에서 컴포넌트가 LoginForm에서 UserProfile로 리렌더링된다.

5. 액션과 상태 정리하기
1. 액션명 정리하기
액션명이 문자열로 되있는 경우 오타에 취약하다는 단점이 있다. 이럴 때는 변수로 빼두는 것을 추천한다.
변수로 만들어주면 에디터가 오타를 캐치해주므로 관리하기가 좋다. 혹시라도 해당 부분이 너무 길어진다면 action에 관련된 폴더를 따로 만들어서 관리해줘도 된다.

reducer 폴더에 있는 user.js에 필요한 action들을 수정 및 추가해주고 post.js도 수정해주자.

[source,js]
----
// reducer/user.js
...
export const LOG_IN_REQUEST = 'LOG_IN_REQUEST';
export const LOG_IN_SUCCESS = 'LOG_IN_SUCCESS';
export const LOG_IN_FAILURE = 'LOG_IN_FAILURE';

export const LOG_OUT_REQUEST = 'LOG_OUT_REQUEST';
export const LOG_OUT_SUCCESS = 'LOG_OUT_SUCCESS';
export const LOG_OUT_FAILURE = 'LOG_OUT_FAILURE';

export const SIGN_UP_REQUEST = 'SIGN_UP_REQUEST';
export const SIGN_UP_SUCCESS = 'SIGN_UP_SUCCESS';
export const SIGN_UP_FAILURE = 'SIGN_UP_FAILURE';

export const UNFOLLOW_REQUEST = 'UNFOLLOW_REQUEST';
export const UNFOLLOW_SUCCESS = 'UNFOLLOW_SUCCESS';
export const UNFOLLOW_FAILURE = 'UNFOLLOW_FAILURE';

export const FOLLOW_REQUEST = 'FOLLOW_REQUEST';
export const FOLLOW_SUCCESS = 'FOLLOW_SUCCESS';
export const FOLLOW_FAILURE = 'FOLLOW_FAILURE';

// action creators
export const loginRequestAction = (data) => {
    return {
        type: LOG_IN_REQUEST,
        data,
    }
};

export const logoutRequestAction = () => {
    return {
        type: LOG_OUT_REQUEST,
    }
};

const reducer = (state = initialState, action) => {
    switch (action.type) {
        case LOG_IN_REQUEST:
            return {
                ...state,
                isLoggingIn: true,
            };
        case LOG_IN_SUCCESS:
            return {
                ...state,
                isLoggingIn: false,
                isLoggedIn: true,
                me: { ...action.data, nickname: 'mag' },
            };
        case LOG_IN_FAILURE:
            return {
                ...state,
                isLoggingIn: false,
                isLoggedIn: false,
            };
        case LOG_OUT_REQUEST:
            return {
                ...state,
                isLoggingOut: true,
            };
        case LOG_OUT_SUCCESS:
            return {
                ...state,
                isLoggingOut: false,
                isLoggedIn: false,
                me: null,
            };
        case LOG_OUT_FAILURE:
            return {
                ...state,
                isLoggingOut: false,
            };
        default:
            return state;
    }
};

export default reducer;
----

[source,js]
----
// reducer/post.js

...
export const ADD_POST_REQUEST = 'ADD_POST_REQUEST';
export const ADD_POST_SUCCESS = 'ADD_POST_SUCCESS';
export const ADD_POST_FAILURE = 'ADD_POST_FAILURE';

// action creators
export const addPost = (data) => ({
    type: ADD_POST_REQUEST,
    data,
});

const dummyPost = {
    id: 2,
    content: '더미데이터입니다~',
    User: {
        id: 1,
        nickname: 'magrfs',
    },
    Images: [],
    Comments: [],
}

const reducer = (state = initialState, action) => {
    switch (action.type) {
        case ADD_POST_REQUEST:
        case ADD_POST_SUCCESS:
            return {
                ...state,
                isAddingPost: false,
                mainPosts: [dummyPost, ...state.mainPosts],
                postAdded: true,
            };
        case ADD_POST_FAILURE:
        default:
            return state;
    }
};

export default reducer;
----

2. 상태명 정리하기

reducer의 user.js에 initialState를 보면 isLoggedIn과 같은 상태들이 점점 늘어나는 것을 볼 수 있다. 유저와 관련되어서 follow 등을 추가하면 더 길어질것이다. 이럴 때, 이름을 어느정도 규칙을 세워서 만들어주면 좋다. 100% 옳다라는 방법은 없지만 본인 및 팀원들이 알기 쉬운 이름으로 짓는게 좋다.

[source,js]
----
// reducer/user.js

export const initialState = {
    logInLoading: false, // 로그인 시도중
    logInDone: false,
    logInError: null,
    logOutLoading: false, // 로그아웃 시도중
    logOutDone: false,
    logOutError: null,
    signUpLoading: false, // 회원가입 시도중
    signUpDone: false,
    signUpError: null,
    me: null,
    signUpData: {},
    loginData: {},
};
...
----

initialState를 바꿨다면 이제 reducer도 바꿔줘야한다.
loading 액션 시 me를 null로 설정해주면 아무런 데이터 없이 로딩을 보여주느냐 아니냐를 설정할 수 있다. 하지만 대부분 loading에서가 아니라 실패했을 시 데이터를 없애버린다.

reducer를 설정하면서 추가로 회원강비에 대한 reducer 코드도 작성해보자. 특별한 경우가 아닌 이상 대부분 복사-붙여넣기 수준이다.

error의 경우에도 action.data -> action.error 로 수정해주자.

[source,js]
----
// reducer/user.js

...
const reducer = (state = initialState, action) => {
    switch (action.type) {
        case LOG_IN_REQUEST:
            return {
                ...state,
                logInLoading: true,
                logInDone: false,
                logInError: null,
            };
        case LOG_IN_SUCCESS:
            return {
                ...state,
                logInLoading: false,
                logInDone: true,
                me: dummyUser(action.data),
            };
        case LOG_IN_FAILURE:
            return {
                ...state,
                logInLoading: false,
                logInError: action.error,
            };
        case LOG_OUT_REQUEST:
            return {
                ...state,
                logOutLoading: true,
                logOutDone: false,
                logOutError: null,
            };
        case LOG_OUT_SUCCESS:
            return {
                ...state,
                logOutLoading: true,
                logOutDone: false,
                me: null,
            };
        case LOG_OUT_FAILURE:
            return {
                ...state,
                logOutLoading: false,
                logOutError: action.error,
            };
        case SIGN_UP_REQUEST:
            return {
                ...state,
                signUpLoading: true,
                signUpDone: false,
                signUpError: null,
            };
        case SIGN_UP_SUCCESS:
            return {
                ...state,
                signUpLoading: false,
                signUpDone: true,
            };
        case SIGN_UP_FAILURE:
            return {
                ...state,
                signUpLoading: false,
                signUpError: action.error,
            };
        default:
            return state;
    }
};
----

3. saga에서 액션명 정리하기

reducer쪽에서 액션명을 변수에 저장하고 그외에 코드가 수정된 부분이 있으므로 saga에서도 같이 수정을 해줘야한다. error도 원래 data에 담기던걸 error에 담아주자.

[source,js]
----
// sagas/user.js

...
import {
    LOG_IN_REQUEST, LOG_IN_SUCCESS, LOG_IN_FAILURE,
    LOG_OUT_REQUEST, LOG_OUT_SUCCESS, LOG_OUT_FAILURE,
    SIGN_UP_REQUEST, SIGN_UP_SUCCESS, SIGN_UP_FAILURE,
} from '../reducers/user';

function logInAPI(data) {
    return axios.post('/api/login', data);
}

function* logIn(action) {
    try {
        // const result = yield call(logInAPI, action.data);
        yield delay(1000);
        yield put({
            type: LOG_IN_SUCCESS,
            data: action.data,
        });
    } catch (err) {
        yield put({
            type: LOG_IN_FAILURE,
            error: err.response.data,
        });
    }
}

function logOutAPI() {
    return axios.post('/api/logout');
}

function* logOut() {
    try {
        // const result = yield call(logOutAPI);
        yield delay(1000);
        yield put({
            type: LOG_OUT_SUCCESS,
            // data: result.data,
        });
    } catch (err) {
        yield put({
            type: LOG_OUT_FAILURE,
            error: err.response.data,
        });
    }
}

function signUpAPI() {
    return axios.post('/api/signup');
}

function* signUp() {
    try {
        // const result = yield call(signUpAPI);
        yield delay(1000);
        yield put({
            type: SIGN_UP_SUCCESS,
            // data: result.data,
        })
    } catch (err) {
        yield put({
            type: SIGN_UP_FAILURE,
            error: err.response.data,
        })
    }
}

function* watchLogIn() {
    yield takeLatest(LOG_IN_REQUEST, logIn);
}

function* watchLogOut() {
    yield takeLatest(LOG_OUT_REQUEST, logOut);
}

function* watchSignUp() {
    yield takeLatest(SIGN_UP_REQUEST, signUp);
}

export default function* userSaga() {
    yield all([
        fork(watchLogIn),
        fork(watchLogOut),
        fork(watchSignUp),
    ]);
}
----

post쪽도 reducer, saga 전부 수정해주자.

[source,js]
----
// reducer/post.js
export const initialState = {
    mainPosts: [{
        id: 1,
        User: {
            id: 1,
            nickname: 'magrfs',
        },
        content: '첫 번째 게시글입니다.',
        Images: [{
            src: '...'
        }, {
            src: '...'
        }, {
            src: '...'
        }],
        Comments: [{
            User: {
                nickname: 'hello',
            },
            content: '첫 번째 댓글이예요!',
        }, {
            User: {
                nickname: 'huhuhu',
            },
            content: '두 번째 댓글이예요!',
        }
        ],
    }],
    imagePaths: [],
    addPostLoading: false,
    addPostDone: false,
    addPostError: null,
    addCommentLoading: false,
    addCommentDone: false,
    addCommentError: null,
};

export const ADD_POST_REQUEST = 'ADD_POST_REQUEST';
export const ADD_POST_SUCCESS = 'ADD_POST_SUCCESS';
export const ADD_POST_FAILURE = 'ADD_POST_FAILURE';

export const ADD_COMMENT_REQUEST = 'ADD_COMMENT_REQUEST';
export const ADD_COMMENT_SUCCESS = 'ADD_COMMENT_SUCCESS';
export const ADD_COMMENT_FAILURE = 'ADD_COMMENT_FAILURE';

// action creators
export const addPost = (data) => ({
    type: ADD_POST_REQUEST,
    data,
});

export const addComment = (data) => ({
    type: ADD_COMMENT_REQUEST,
    data,
});

const dummyPost = {
    id: 2,
    content: '더미데이터입니다~',
    User: {
        id: 1,
        nickname: 'magrfs',
    },
    Images: [],
    Comments: [],
}

const reducer = (state = initialState, action) => {
    switch (action.type) {
        case ADD_POST_REQUEST:
            return {
                ...state,
                addPostLoading: true,
                addPostDone: false,
                addPostError: null,
            };
        case ADD_POST_SUCCESS:
            return {
                ...state,
                mainPosts: [dummyPost, ...state.mainPosts],
                addPostLoading: false,
                addPostDone: true,
            };
            ...
    }
}
----

...

React - 상태관리 Redux-Saga 2022.08.03
https://ji-musclecode.tistory.com/67


Redux의 미들웨어로 많이 사용되는 Redux-Saga

redux-saga는 redux middleware 라이브러리 중 하나로, Action과 Reducer 사이에서 흐름을 제어함.
Action을 모니터링 하다가 Action이 발생하면 Reducer가 Action을 처리하기 전에 다양한 작업을 할 수 있음

* 기존 요청 취소, 불필요한 중복 요청 방지 가능
* 비동기 작업을 처리하는데 효과적
* 특정 Action이 발생했을 때 이에 따라 다른 Action이 Dispatch 되게 하거나, JS 코드를 실행할 수 있음

1. actions, reducers, sagas 폴더를 만들고 파일들을 만들어줌.
actions/playAction.js
reducers/index.js
sagas/PlaySaga.js, rootSaga.js

예제 확인을 위해 API, Components 폴더를 만들고 각각 파일을 만들어줌.
API/API.js
Components/index.js, play1.js

2. 위에서 만든 Redux-Saga를 적용

기존 Redux의 store를 선언할 때와 비교해보면 createSagaMiddleware로 미들웨어를 만들어 applyMiddleware로 적용시키고 rootSaga를 넣어서 해당 Saga를 적용할 것이라고 알려주는 것이 추가됨

3. redux-saga 사용

기존 Redux를 적용시켰을 때와 비교해보면 별 다른 차이점이 없음. 하지만 내부 데이터 흐름이 다름.

4. 결과 확인
1 에서 10 까지 순서대로 나옴

5. 데이터 흐름 확인

debugger 와 콘솔을 찍으면서 확인

* mapDispatchToProps에서 정의했던 PostsRequest 함수 호출
* PostRequest 액션 함수가 호출됨. PostsRequest 함수는 "getPosts"라는 type을 리턴하여 액션이 발생
* redux-saga에서는 이를 감지하고 액션에 해당하는 동작 getPostData 함수를 호출
* getPostData 함수는 yield call을 만나 함수의 리턴이 있을 때까지 기다림
* 즉 callSelectAPI 함수를 호출하고 callSelectAPI 함수는 axios.get()을 통해 받아온 데이터를 리턴하면 다음 동작을 수행함
* yield put을 만나 새로운 액션에 대해 Displatch
* reducer에 액션에 대한 state 변경이 있으므로 이를 수행함
* 변경된 state는 mapStateToProps를 통해서 컴포넌트에 전달되고 우리는 최종적으로 4번의 결과 화면이 렌더링 된 것을 확인할 수 있음


https://leego.tistory.com/entry/Redux-saga%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90[Redux-saga를 알아보자 2021.09.04]

redux에서는 action을 발생시키면 reducer를 통해 state를 변화시켜 store를 갱신함

Redux-saga는 action과 reducer사이에서 흐름을 제어하는 미들웨어. 이 중간에서 Redux-saga는 action이 발생하면 reducer가 액션을 처리하기 전에 다양한 작업을 할 수 있다.

다양한 작업들의 예시
* 기존 요청을 취소 처리하거나 불필요한 중복 요청을 방지할 수 있다.
* 비동기 작업을 처리하는데 효과적
* 특정 액션이 발생했을 때 다른 액션을 발생시키거나, 리덕스와 관계없는 코드 실행시 사용함

즉, Redux-saga를 이용하면 보다 간편하면서도 깊게 state의 흐름을 제어할 수 있다.

Redux-saga를 도입한 이유
1. api 호출 로직을 효율적으로 관리할 수 있다.
오로지 비동기 작업만을 위해 redux-saga를 쓰는것은 크게 효율적이지 않다고 생각
async/await 라는 훌륭한 기능으로 비동기 동작들을 처리할 수 있는데 굳이 코드량을 늘려가며 redux-saga를 도입한 이유?

redux-saga에서는 비동기 동작에 대한 더 세부적인 컨트롤이 가능. 예를 들면 사용자의 부주의로 동일한 api를 여러번 호출할 경우, 가장 마지막 호출의 response 만 받아오도록 제어할 수 있다.

무엇보다 api 호출 로직을 saga에서 관리하면서, Presentational 컴포넌트와 Container 컴포넌트의 명확한 분리가 가능해짐. 또한 같은 api를 다른 페이지에서 호출시 같은 코드를 두번 적어줘야 했다면, api 호출 로직을 Redux-saga로 관리하면서 selector로 데이터 만을 간편하게 가져올 수 있게 됨.

