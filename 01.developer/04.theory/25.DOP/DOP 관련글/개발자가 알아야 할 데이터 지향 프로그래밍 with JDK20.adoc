:hardbreaks:

= 개발자가 알아야 할 데이터 지향 프로그래밍 with JDK 20

https://yozm.wishket.com/magazine/detail/2164/

예호나단 샤르빗이 데이터 지향 프로그래밍이라는 새로운 개념을 제안

== 객체 지향 프로그래밍
대부분의 프로그래밍 패러다임에는 "Everything is a ..."형식의 한 문장 슬로건이 있음

* OOP의 경우 "모든 것이 객체입니다."
* 함수형 프로그래밍은 "모든 것이 함수다"
* 액터 기반 시스템은 "모든 것이 액터다"

(모두 과장된 표현)

OOP는 상태와 동작을 결합하는 개체를 사용하여 복잡한 엔티티 및 프로세스를 모델링하도록 권장함

캡슐화와 다형성을 권장

* 캡슐화: 개체 동작이 개체 상태에 대한 액세스를 중재함
* 다형성: 공통 인터페이스 또는 어휘를 사용하여 여러 종류의 엔티티가 상호 작용할 수 있음

하지만 이러한 목표를 달성하기 위한 메커니즘은 OO 언어마다 다름

객체로 세상을 모델링 할 때 is-a (예금 계좌는 은행 계좌) 및 has-a (저축 계좌에는 소유자와 계좌 번호가 있음) 관계의 관점에서 생각하도록 권장됨

각 객체는 공개된 메서드 (Public Method)를 이용해서 메시지를 주고 받음

OOP는 유지 관리 경계, 버전 관리 경계, 캡슐화 경계, 컴파일 경계, 호환성 경계, 보안 경계 등의 경계를 정의하고 방어할 때 가장 좋음

OO 언어는 이러한 경계를 정확하게 정의, 탐색 및 방어하기 위한 도구를 제공

큰 프로그램을 명확한 경계가 있는 더 작은 부분으로 나누면 복잡성을 관리하는 데 도움이 됨
모듈식 추론(한 번에 프로그램의 한 부분을 분석하면서도 전체에 대해 추론하는 기능)이 가능하기 때문

모놀로식 프로그램에서 합리적인 내부 경계를 설정하면 여러 팀에 걸쳐 있는 더 큰 애플리케이션을 구축하는 데 도움이 되었음. 모놀리스 시대에 자바가 번창한 것은 우연이 아님.

절차식 프로그래밍(Procedural programming) 시절에는 프로시저(루틴, 메서드, 함수) 등의 연속적인 계산을 기반으로 코딩했음. 그러나 유지 보수를 위해 만들어진 GOTO, JUMP로 인한 코드의 스파게티 화로 어려움을 느꼈음. 그런데 합리적인 경계를 나누고 복잡성을 관리할 수 있으며, 캡슐화를 통해 모듈식 추론이 가능한 OOP를 쓰지 않을 이유는 없었던 것으로 생각됨.

그 이후로 프로그램은 더 작아졌음. 모놀리식을 구축하는 대신 많은 작은 서비스에서 더 큰 애플리케이션을 구성함. 소규모 서비스 내에서는 내부 경계가 덜 필요해졌음. 충분히 작은 서비스는 단일팀(또는 단일 개발자)에 의해 유지 관리될 수 있음. 마찬가지로 이러한 소규모 서비스 내에서는 장기 실행 상태 저장 프로세스를 모델링 할 필요가 적음.

서비스 등의 로직을 해결하는 클래스를 만드는 경우도 있지만, 데이터를 주고받는 개체를 만드는 일이 더 빈번했음. 요즘에는 자바의 정적 타입을 데이터로 주고받는 명세로서 적극적으로 이용함.

== 외부 세상으로부터의 개체 관리
자바의 정적 타입은 유용하게 쓰임
숫자는 숫자 문자열이 아닌 int또는 long
날짜는 LocalDateTime과 같은 클래스
목록은 긴 쉼표로 구분된 문자열이 아닌 컬렉션으료 표현

== OO는 복잡하다

OO is too complex.

OO에서 코드와 데이터는 클래스로 묶여서 함께 표현됨. 코드는 메서드, 데이터는 멤버 변수

그런데 시스템 분석 관점에서 코드와 데이터가 뒤섞인다는 사실은 엔티티가 많은 관계에 관여하는 경향이 있다는 점에서 시스템을 복잡하게 만듬

데이터의 관계들(Data relations):
* `Library` has `Member`s ->
* `Member` has `BookLending`s

코드의 관계들(Code relations):
* `Member` extends `User`
* `Librarian` uses `Member`
* `Member` uses `BookItem`

데이터와 메서드(로직)가 결합된 '객체'를 이용하여 프로그램을 설계하는 객체지향 프로그래밍 방식을 많이 사용함
그런데 이 객체가 데이터만 전달하는 역할을 할 때, 그 객체 안에 메서드(로직)을 포함시켜야 하는지 아니면 그저 데이터 전달만을 목표로 할지에 대한 의견이 갈림

일부 개발자들은 객체가 '상태'와 '행동'을 함께 갖는 것이 객체지향의 핵심 원칙이라고 주장. 메서드는 객체가 상호작용하는 방식을 정의하며, 이는 객체가 각자의 책임과 역할을 수행하는 데 있어 중요함. 그래서 이런 관점에서는 메서드를 포함시키는 것이 자연스러움

반면 다른 개발자들은 데이터를 전달하는 객체가 단순히 '데이터 컨테이너' 또는 '데이터 구조체'로서 역할을 하도록 설계하는 것이 더 명확하고 간결하다고 주장함. 이들은 함수와 데이터를 분리하고, 데이터는 단순히 전달의 수단으로만 사용하는 것이 프로그램 전체의 복잡성을 줄이고, 코드의 재사용성을 높이는 데 도움이 된다고 생각함.

이렇게 봤을 때, 데이터를 주고받는 객체가 메서드를 포함해야 하는지는 개발 상황, 설계 원칙, 그리고 프로젝트의 요구 사항에 따라 달라질 수 있음

POCO
* Value Object
* DTO


|===
| |DTO |Value Object |POCO

|Contains Data
|yes
|yes
|yes

|Contains Logic
|no
|yes
|yes/no

|Has Own Identity
|no
|no
|yes/no
|===

== DOP(Data Oriented Programming)

TODO