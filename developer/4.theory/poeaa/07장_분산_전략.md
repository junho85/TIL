# 07장 분산 전략 (Distribution Strategies)
* 객체가 처음 선보인 이후 많은 사람들이 객체를 분산하려는 노력을 했다.
* 객체를 분산하는 작업에는 많은 함정이 도사리고 있다.

## 분산 객체의 매력 (The Allure of Distributed Objects)
* 그림 7.1
  * 송장, 고객, 주문, 배송 컴포넌트를 다른 노드에 배치하는 방법으로 애플리케이션을 분산
  * 저자는 이 방식을 권장하지 않음
* 고객, 주문, 제품, 배송을 위한 원격 객체가 각각 분리
* 각 객체는 별도의 프로세싱 노드에 배치할 수 있는 별도의 컴포넌트
* 필자가 형편 없다고 생각 하는 이유
  * 성능이 저하되며 시스템의 구축이나 배포도 훨씬 어려워지기 때문
* 툴 공급업체에서 말하는 분산 객체의 주 목적
  * 다수의 객체를 필요에 따라 원하는 형태로 프로세싱 노드에 배치하기 위해서라고 설명
* 이들의 강력한 미들웨어가 투명성을 제공
* 투명성은 호출하려는 대상이 동일한 프로세스나 다른 프로세스 또는 다른 시스템에 있느냐와 관계없이 객체가 다른 객체를 한 프로세스 안이나 프로세스 간에 호출할 수 있게 해주는 개념
* 투명성은 가치가 높고, 분산 객체의 여러 측면에 긍정적 영향을 주지만
* 일반적으로 성능에는 긍정적 영향을 주지 않음

## 원격 및 로컬 인터페이스 (Remote and Local Interfaces)
* 클래스 모델별 분산이 좋지 않은 생각이라고 말하는 주된 이유
  * 컴퓨터의 기본 작동 원리 때문
  * 분리된 프로세스 간의 프로시저 호출은 분리되지 않은 경우 보다 수십 또는 수백 배 느림
  * 게다가 다른 시스템으로 분리 되면 네트워크 토폴로지에 따라 수십, 수백 배 느려짐
* 로컬 인터페이스는 가는 입자 인터페이스일 때 가장 좋음
  * 예를 들어, 주소 클래스에서 시 얻기, 도 얻기, 시 설정, 도 설정 별도로 있는게 좋은 인터페이스
  * 원격 환경에는 잘 맞지 않음. 메서드 호출이 느리기 때문
  * 호출 횟수 최소화를 위한 굵은 입자 인터페이스
  * 즉, 주소 세부 사항 얻기, 주소 세부 사항 업데이트 등의 메서드가 포함된 인터페이스가 만들어짐
* 분산 객체 설계의 첫 번째 규칙 - "객체를 분산하지 말라"
* 다중 프로세서를 효과적으로 활용하려면
  * 클러스터링이 가장 적합 (그림 7.2)
    * oa 가 뭐지? 아마 Order Application 의 약자로 보인다.
  * 모든 클래스를 단일 프로세스에 넣고 해당 프로세스의 여러 복사본을 다수의 노드에서 실행하는 것

## 분산이 필요한 상황 (Where You Have to Distribute)
* 클라이언트와 서버 간의 분리
* 애플리케이션 서버와 데이터베이스
* 웹 시스템 - 웹 서버와 애플리케이션 서버 간
  * 조건이 허락한다면 웹서버와 애플리케이션 서버를 단일 프로세스로 실행하는 것이 좋지만 항상 가능하지는 않음
* 공급업체 간의 차이 - 소프트웨어 패키지는 일반적으로 자체 프로세스 안에서 실행 됨
  * v3 서버 같은거?
* 합당한 이유가 있는 경우
* 정리: 객체 분산은 도무지 방법이 없을 때 사용하는 최후의 수단으로 미뤄야 한다.

## 분산 경계를 사용한 작업 (Working with The Distribution Boundary)
* 모든 원격 호출은 추가 비용을 지불하고 실행된다.
* 원격 파사드(412)
  * 굵은 입자 객체를 분산 경계에 배치
  * 분산 용도로만 사용
  * 원격 서비스가 정말 필요한 객체만 굵은 입자 메서드를 사용
* 마지막에 "브로커를 통해 객체를 프로세스 간에 마이그레이션해 분산을 구현하는 방법도 있다..." 부분은 무슨 이야기인지 아직 이해를 못했다. 원서를 좀 확인 해 봐야 겠다.

## 분산을 위한 인터페이스 (Interfaces for Distribution)
* XML over HTTP 에 기반을 두는 인터페이스가 나타나기 시작
  * e.g. SOAP
  * 이 책이 2002년에 쓴 책이란걸 염두하자.
  * 2018년 기준으로 RESTful API 와 JSON 이 아마 가장 많이 쓰이지 않을까 싶다.
  * GraphQL 이라는 Server API 를 구성하기 위해 Facebook 에서 만든 Query Language 도 점점 쓰이고 있음
  * 관련글: [GraphQL과 RESTful API 2018.01.20](https://www.holaxprogramming.com/2018/01/20/graphql-vs-restful-api/)
* XML over HTTP 통신 장점
  * 많은 양의 데이터를 구조화된 형식을 통해 단 한번의 왕복으로 손쉽게 전송할 수 있다. 원격 호출 최소화에 도움
  * XML
    * 여러 플랫폼에서 지원되는 파서로 구문 분석이 가능한 공용 포맷
    * XML 은 텍스트 형식이라 전송 중인 내용을 확인 하기 쉬움
  * HTTP
    * 어디서나 범용 표준으로 통용
* 지금까지 동기식 RPC 기반 인터페이스
* 근본적으로 비동기적인 메시지 기반 방식이 더 좋다고 생각. 지면상 생략

## 덧붙임
### 저자의 분산에 대한 생각 변화?
* 이 책은 저자가 2002년에 쓴 것인데 분산을 많이 지양 하는 것을 느낄 수 있다. 가급적 분산을 하지 말고 필요한 경우에만 하라고 한다.
* 그런데 2015년에 저자가 쓴 [Microservice Trade-Offs 2015.07.01](https://martinfowler.com/articles/microservice-trade-offs.html) 글을 보면 조금은 더 긍정적으로 돌아 선 것으로 보인다.
  * 번역글
    * http://chanwookpark.github.io/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4/%EB%B2%88%EC%97%AD/%EB%A7%88%ED%8B%B4%ED%8C%8C%EC%9A%B8%EB%9F%AC/2016/01/29/microservice-trade-off/
    * https://edykim.com/ko/post/microservice-tradeoff/

### RPC 에 대해
* RPC 히스토리는 좀 정리 해 둘 필요가 있어 보인다. 일단 기억나는 것들 몇가지 메모
* 현재 (2018년 기준) RESTful API 가 대세 인 것으로 보인다. 그리고 Facebook 에서 선보인 GraphQL 이 뜨고 있는 것 같다. 
  * [GraphQL과 RESTful API 2018.01.20](https://www.holaxprogramming.com/2018/01/20/graphql-vs-restful-api/) 글을 읽어 봐야 겠다.
* 2008년 정도? AJAX 가 유행하기 시작하던 시절이다. 특이한건 AJAX 의 X 는 XML 인데 얼마 지나지 않아 간편한 JSON 이 더 각광 받게 되었다. 
* 2000년대 초반에는 이 책에서 언급된 XML over HTTP 이 유행 하였다.
* Java RPC, Hessian 등등 다양한 방식들이 있는데 따로 더 정리 해 봐야 겠다.

### 데이터 전송 객체 DTO 클래스
* DTO 에 대해서는 사람마다 의견이 좀 분분한 부분이 있는데 DTO 클래스를 꼭 만들어 쓰느냐이다.
  * 개인적인 느낌으로는 매번 인터페이스를 만들어야 되느냐와 비슷한 느낌?
  * 꼭 필요한 경우가 아니라면 굳이 DTO 클래스를 만들어 쓸 필요는 없다고 생각한다.
  * 주 이유는 번거롭기 때문이다.
  * JavaScript 같은 언어에서는 그냥 쓰는데 크게 문제 되지 않는다.
  * Perl 에서도 그냥 JSON 을 Hash 로 바꿔서 쓰는게 편하다.
  * Java 같은 언어에서도 DTO 클래스를 만들기 보다는 HashMap 같은데 맵핑해서 쓰는게 손쉬운 경우가 많다. 

### 가는 입자, 굵은 입자
* 분산을 할 때 굵은 입자 방식으로 한번에 많은 정보를 한번에 주고 받는 것을 권장 하고 있다.
* 물론 여기에도 trade off 가 있다고 본다.
* 특별한 문제가 없다면 가는 입자로도 충분하다고 본다. (이 부분에 대해서도 좀 논쟁거리가 될 수 있다고 생각한다.)
* 굵은 입자로 바꿔야 되는 경우로
  * 속도가 서비스에 영향을 줄 만큼 너무 느려지는 상황이 발생
  * 개발자 비용에 여유가 있을 때 서비스를 최적화 하고자 하는 경우

### 비동기적인 메시지 기반 방식?
* 비동기적인 메시지 기반 방식에 대해서는 자세히 언급 하고 있지 않다.
* 해야될 작업을 메시지큐에 쌓아 두고 그걸 꺼내서 처리 하는 방식이 아닐까 싶다. 이 부분에 대해서도 따로 좀 더 조사해보고 정리 해 보는게 좋겠다.
* [비동기 메시지 기반 통신](https://docs.microsoft.com/ko-kr/dotnet/standard/microservices-architecture/architect-microservice-container-applications/asynchronous-message-based-communication)

#### CQRS?
* CQRS 도 비슷한건가?
* [CQRS(명령 및 쿼리 책임 분리) 패턴](https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs)
* 뭐랄까. MySQL DB 의 BIN 로그와 비슷하다고나 할까?
* 여기에 대해서도 좀 더 알아 봐야 겠다.