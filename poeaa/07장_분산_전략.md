# 07장 분산 전략 (Distribution Strategies)
* 객체가 처음 선보인 이후 많은 사람들이 객체를 분산하려는 노력을 했다.
* 객체를 분산하는 작업에는 많은 함정이 도사리고 있다.

## 분산 객체의 매력 (The Allure of Distributed Objects)
* 그림 7.1
  * 송장, 고객, 주문, 배송 컴포넌트를 다른 노드에 배치하는 방법으로 애플리케이션을 분산
  * 저자는 이 방식을 권장하지 않음
* 고객, 주문, 제품, 배송을 위한 원격 객체가 각각 분리
* 각 객체는 별도의 프로세싱 노드에 배치할 수 있는 별도의 컴포넌트
* 필자가 형편 없다고 생각 하는 이유
  * 성능이 저하되며 시스템의 구축이나 배포도 훨씬 어려워지기 때문
* 툴 공급업체에서 말하는 분산 객체의 주 먹적은 다수의 객체를 필요에 따라 원하는 형태로 프로세싱 노드에 배치하기 위해서라고 설명
* 이들의 강력한 미들웨어가 투명성을 제공
* 투명성은 호출하려는 대상이 동일한 프로세스나 다른 프로세스 또는 다른 시스템에 있느냐와 관계없이 객체가 다른 객체를 한 프로세스 안이나 프로세스 간에 호출할 수 있게 해주는 개념
* 투명성은 가치가 높고, 분산 객체의 여러 측면에 긍정적 영향을 주지만 일반적으로 성능에는 긍정적 영향을 주지 않음


## 원격 및 로컬 인터페이스 (Remote and Local Interfaces)
* 클래스 모델별 분산이 좋지 않은 생각이라고 말하는 주된 이유
  * 컴퓨터의 기본 작동 원리 때문
  * 분리된 프로세스 간의 프로시저 호출은 분리되지 않은 경우 보다 수십 또는 수백 배 느림
  * 게다가 다른 시스템으로 분리 되면 네트워크 토폴로지에 따라 수십, 수백 배 느려짐
* 로컬 인터페이스는 가는 입자 인터페이스일 때 가장 좋음
  * 예를 들어, 주소 클래스에서 시 얻기, 도 얻기, 시 설정, 도 설정 별도로 있는게 좋은 인터페이스
  * 원격 환경에는 잘 맞지 않음. 메서드 호출이 느리기 때문
  * 호출 횟수 최소화를 위한 굵은 입자 인터페이스
  * 즉, 주소 세부 사항 얻기, 주소 세부 사항 업데이트 등의 메서드가 포함된 인터페이스가 만들어짐
* 분산 객체 설계의 첫 번째 규칙 - "객체를 분산하지 말라"
* 다중 프로세서를 효과적으로 활용하려면
  * 클러스터링이 가장 적합 (그림 7.2)
  * 모든 클래스를 단일 프로세스에 넣고 해당 프로세스의 여러 복사본을 다수의 노드에서 실

## 분산이 필요한 상황 (Where You Have to Distribute)
* 클라이언트와 서버 간의 분리
* 애플리케이션 서버와 데이터베이스
* 웹 시스템 - 웹 서버와 애플리케이션 서버 간
  * 조건이 허락한다면 웹서버와 애플리케이션 서버를 단일 프로세스로 실행하는 것이 좋지만 항상 가능하지는 않음
* 공급업체 간의 차이 - 소프트웨어 패키지는 일반적으로 자체 프로세스 안에서 실행 됨
  * v3 서버 같은거?